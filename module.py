# Pyton3模块
'''
使用python解释器来编程，如果你从Python解释器退出在进入，那么定义的所有方法和变量就消失了
为此python提供一个方法，把这些定义存放在文件中，为一些脚本或者交互式解释器使用，这个文件称为模块
模块是一个包含所有定义的函数和变量的文件，其后缀名为.py，模块可以被别的程序引入，以使用该模块中的函数等功能
python标准库就是有许多模块组成的
'''

# import语句
'''
想使用Python源文件，只需在另一位源文件里执行import语句
import module1[,module2...]
当解释器遇到import语句，如果模块在当前的搜索路径就会被导入
搜索路径是一个编译器会先进行搜索的目录列表。如果
'''

'''
一个模块只会被导入一次，不管执行多少次。
当我们使用import语句的时候，Python解释器通过搜索路劲去寻找所引入的模块，看起来像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径
搜索路径在Python编译或者安装的时候确定的，安装新的库也会修改。搜索路径被存储在sys模块中的path变量
通过sys.path变量来查看搜索路径

sys.path第一项是一个空串，代表当前目录，即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）
因此如果在当前目录下存在要引入模块的同名文件，就会把要引入的模块屏蔽掉
'''

# from...import语句
'''
Python的from语句让我们可以从模块中导入一个指定的部分到当前命名空间中
'''

# 深入模块
'''
模块出来方法定义，还可以包括可执行的代码，这些代码，一般用来初始化一个模块。这些代码只有在第一次被导入时菜会被执行
每个模块有给自独立的符号表，在模块内部为所有函数当作全局符号表来使用（符号表是什么,其实就是该模块名字，用于区分其他模块）
所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混
从另一方面，当你确实知道你在做什么的化，也可以通过modname.itemname这样的表示法来访问模块内的函数。
模块是可以导入其他模块的。在一个模块（或者脚本、或者其他地方）的最前面使用import来导入一个模块。被导入的模块的名称将放到当前操作的模块的符号表中。
'''

# from fibo import fib, fib2 这种导入方法不会把被导入模块的名称放在当前的字符表中
# from fibo import 这将把所有的名字都导入进来，但是哪些单一下划线开头的名字不在此列。Python程序员不适用这种方法，因为引入其它来源的命名，很可能覆盖了已有的定义

# __name__属性（这里还有待深入了解）
'''
一个模块被另一个程序引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来是该程序块仅在该模块自身运行时执行
'''

if __name__ == '__main__':  # 这是将文件视为模块对象来执行吗？
    print("程序自身在运行")
else:
    print("我来自另一模块")
'''
每个模块都有一个__name__属性，其值是'__main__'时，表面该模块自身在运行，否则是被引入
'''

# dir()函数
'''
内置的函数dir()可以找到模块内定义的所有名称。以一个字符串列表的形式返回
'''

# 标准模块
'''
Python本身带着一些标准的模块库
有些模块直接被构建在解释器里面，这些虽然不是语言内置的功能，但是他却能很高效的使用，甚至系统级调用也没问题(直接内置在解释器中的模块怎么理解？)
这些组件会根据不同的操作系统进行不同的配置
特别注意sys模块，它内置在每个Python解释器中
'''

# 包
'''
包是一种管理Python模块命名空间的形式，采用".modname"
就好像使用模块时候，不用担心不同模块之间的全局变量相互影响一样，采用.modname名称这种心事也不用担心不同库之间模块重名的情况
在导入一个包的时候，Python会根据sys.path中的目录来寻找这个包中包含的子目录
目录中只有包含一个叫做__init__.py的文件才会人做是一个包，主要是为了避免一些滥俗的名字影响搜索路径中的有效模块
最简单情况下，放一个空的__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍）__all__变量赋值
使用 from package import item这种形式的时候，对应的item既可以时包里面的自爆，或者包里面的模块、函数、变量
import语法会首先把item当作包定义的名称，如果没找到，再视图按照一个模块去寻找，如果还没有找到就抛出一个一场
如果使用import item.subitem.subsubitem这种形式导入，出来最后一项必须都是包，而最后一项可以是模块或者是包，不可以时类、函数或者变量名字
'''

# 从一个包中导入 *
'''
如果我们使用from sound.effects import *
Python会进入文件系统，找到这个包里面所有的子模块，然后一个个把它们导入进来
但这个方法再Windows平台上工作就不是非常号，因为Windows不区分大小写
再Windows平台上，我们就无法确定一个叫做ECHO.py的文件导入为模块时echo还是Echo
为了解决这个问题，我们只需要提供一个精确包索引
导入语句遵循如下规则：如果包定义文件__init__.py存在一个叫做__all__的列表变量，那么在使用from package imort *的时候这个列表中所有的名字作为包内容导入
作为包的作者，在更新包之后保证__all__也要更新
'''

'''
__all__ = ["echo", "surround", "reverse"]
标识当你使用 from sound.effects import * 这种用法时，你只会导入包里面这三个子模块
如果没有定义，那么使用这个语法时，久不会导入包sound.effects里的任何子模块(就命名是包开始找，而不是从模块开始)。它只是把包sound.effedts和它里面定义的所有内容导入进来(可能运行_init__.py里定义的初始化代码)
'''

'''
如果在结构中包是一个子包，而邮箱导入兄弟包，就的使用导入绝对路径来导入。比如，如果模块sound.filters.vocoder要使用包sound.effects中的echo模块，你就要写成from sound.effects import
'''

'''
无论是隐式的还是显示的相对导入都是从当前模块开始的。主模块的名字永远是"__main__"，一个Python引用程序的主模块，应当总是使用绝对路径引用。
包还提供一个额外的属性__path__。这是一个目录列表，里面一个包含的目录都有为这个包服务的__init__.py,得在其他__init__.py被执行前定义，可以修改这个变量，来影响包含在包里面的模块和子包。
'''

'''
在Python中，`__path__`属性是一个特殊的属性，用于表示一个包的导入路径。

当一个模块被导入时，Python解释器会搜索模块的导入路径来找到对应的模块文件。对于包（package）而言，它是一个包含多个模块的目录，因此需要告诉解释器在哪里搜索包的模块。

`__path__`属性是一个列表，包含了包的搜索路径。每当导入包时，解释器会根据`__path__`属性中的路径进行搜索，并在这些路径下查找对应的模块文件。

通常情况下，`__path__`属性是由Python解释器自动设置的，它会根据包的目录结构来确定包的搜索路径。对于单个模块的导入，`__path__`属性会是一个包含一个元素的列表，即包的所在路径。

需要注意的是，`__path__`属性一般不需要手动修改或操作。它是由Python解释器根据包的目录结构自动设置的，用于支持包的导入和模块搜索功能。
'''
